(* Copyright (C) 2020 infotheo authors, license: LGPL-2.1-or-later            *)
From HB Require Import structures.
From mathcomp Require Import all_ssreflect all_algebra fingroup finalg matrix.
From mathcomp Require Import mathcomp_extra contra Rstruct ring reals.
Require Import realType_ext realType_ln ssr_ext ssralg_ext bigop_ext fdist.
Require Import proba jfdist_cond entropy.

(**md**************************************************************************)
(* # Computation Security Propositions                                        *)
(* ```                                                                        *)
(******************************************************************************)

Set Implicit Arguments.
Unset Strict Implicit.
Import Prenex Implicits.

Import GRing.Theory Num.Theory.

Local Open Scope nat_scope.
Local Open Scope ring_scope.
Local Open Scope reals_ext_scope.
Local Open Scope proba_scope.
Local Open Scope fdist_scope.
Local Open Scope entropy_scope.
Local Open Scope vec_ext_scope.

Section definitions.
Context {R : realType}.
Variables (T A : finType) (P : R.-fdist T) (k : nat).

(* Commonly the "computational indistinguishability" is defined as:

  "Let X and Y be two distribution ensembles indexed by a security parameter n
    (which usually refers to the length of the input)... "

  In the paper "How to Simulate It in Isabelle: Towards Formal Proof for Secure
  Multi-Party Computation"\cite{Butler2017}, the authors generalized the
  definition above:

  "We model a probability ensemble as having some input of of this type,
   and a natural number security size parameter. The space of events considered
   depends on the view ; also of arbitrary first-order type, ν.

        type synonym (α, ν) ensemble = α ⇒ nat ⇒ ν spmf"
*)
Definition ensembleT := A -> nat -> R.-fdist T.

(* "...we say they are computationally indistinguishable if for any non-uniform
   probabilistic polynomial time algorithm A..."

  In the paper\cite{Butler2017}, the authors also avoided to define the function
  as the definition above:
 
  "We do not formalise a notion of polynomial-time programs in Isabelle as we do
  not need it to capture the following proofs. In principle this could be done
  with a deep embedding of a programming language, its semantic denotation
  function and a complexity measure. Instead, we will assume a family of
  constants giving us the set of all polynomial-time distinguishers for every
  type ν, indexed by a size parameter." \cite[\S3]{Butler2017}

  Since we use `T` as event type, we can define our polydist as follows:
*)
Definition dingT := (size (enum T)).-tuple (R.-fdist T * R.-fdist bool)%type.
(* Because we already have "dist", ChatGPT suggested to use `ding`...*)
(* Using a pair instead of `R.-fdist T -> R.-fdist bool` because
   a \in k.-bseq (R.-fdist T -> R.-fdist bool) will cause an error about
   that "k.-bseq (R.-fdist T -> R.-fdist bool) is not a pred_sort".
*)

Variable polydist : nat -> seq dingT.
(* The nat is a size parameter\cite[\S3]{Butler2017}

   While in "How to Simulate It – A Tutorial on the Simulation Proof Technique"
   \cite[\S2]{Lindell2017}, it explains a bit more:

   "In the context of secure computation, the value `a` will represent the
   parties’ inputs and `n` will represent the security parameter."

  "All parties are assumed to run in time that is polynomial in the security
  parameter. (Formally, every party considered has a security parameter tape
  upon which the value 1^n is written. Then the party is polynomial in the input
  on this tape. We note that this means that a party may not even be able to
  read its entire input, as would occur in the case where its input is longer
  than its overall running time.)"

  The "security parameter" looks like the "128" in AES-128: a key length
  or something like that. It is not the length of the input. Therefore,
  since the "size" here is also used to index random variable in the ensemble,
  why it should be here is that for all security parameters, there must be
  a set of distinguishers, that can distinguish the random variable indexed by
  it. And since the ensembles are infinite sequence, computational
  indistinguishability holds regardless `n`.
*)
(*
  Compare to the Isabelle work \cite[\S3]{Butler2017}:

  "...Instead, we will assume a family of constants giving us the set of all
   polynomial-time distinguishers for every type ν, indexed by a size parameter.
   A polynomial-time distinguisher “characterises” an arbitrary spmf.

        consts polydist :: nat ⇒ (ν spmf ⇒ bool spmf ) set

  ", where spmf stands for "Subprobability mass functions.
  An spmf encodes a discrete (sub) probability distribution."
  \cite[\S2]{Butler2017}
*)


(* "...the following quantity is a negligible function in n:"

   "A negligible function is a function e :: N → R such that for all c ∈ N
   there exists N_c ∈ N such that for all x > N_c we have |e(x)| < 1/x^c"
   \cite[\S3]{Butler2017}
*)
Definition is_negfn (e : nat -> R) (x : nat) :=
  forall (c : nat), exists Nc : int,
    (x > Nc) -> 0 <= e x -> ((x ^ c)%:R * e x) < 1.

Variable (X Y : ensembleT).

(* A fallback dist give prob 1.0 to "false" and 0.0 to "true".
   It is used for `nth` because we use a seq of pairs instead of a mapping
   function to define polydist.
*)
Let dist_false := @fdist1 R bool false.

(*
comp indist :: (α, ν) ensemble ⇒ (α, ν) ensemble ⇒ bool
where comp indist X Y ≡
  ∀(D :: ν spmf ⇒ bool spmf ). ∃ (ǫ :: nat ⇒ real ).
    negligible ǫ ∧ (∀ (a :: α) (n :: nat ). 
      (D ∈ polydist n) -> |spmf (D (X a n)) True − spmf (D (Y a n)) True| ≤ ǫ n))
*)
Definition comp_indist :=
  forall (a : A)(n : nat) (d : dingT),
    exists e : nat -> R, is_negfn e n -> d \in polydist n ->
      let dingX := nth (X a n, dist_false) d (find (fun p => p.1 == X a n) d) in
      let dingY := nth (Y a n, dist_false) d (find (fun p => p.1 == Y a n) d) in
      let diff := dingX.2 true - dingY.2 true in
      if diff > 0 then diff <= e n else dingY.2 true - dingX.2 true <= e n.
      (* Because I cannot find absolute value definition for type R *)
  
End definitions.

Section example.
Context {R : realType}.
Variable (A T TX TY : finType) (m n k : nat).
  
About comp_indist.

Hypothesis cardTX : #|TX| = m.+1.
Hypothesis cardTY : #|TY| = n.+1.

(* Dummy ensembles. Real ones are from the probalistic program of the protocol*)
Let distX := @fdist_uniform R TX m cardTX.
Let distY := @fdist_uniform R TY n cardTY.
Let X : @ensembleT R TX A := fun (a : A)(n : nat) => distX.
Let Y : @ensembleT R TY A := fun (a : A)(n : nat) => distY.
Let distB := @fdist_uniform R bool 1 card_bool.

(* TODO: even for a dummy example each t : T still needs a pair of dingT
   to complete the polydist. So I need a concrete T to make an example.
*)


End example.

Section iwamoto.
  
Search "markov".
Print markov_chain.

End iwamoto.
